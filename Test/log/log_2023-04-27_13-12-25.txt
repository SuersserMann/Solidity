2.0.0
device= cpu
[[1, 'if(msg.sender.call.value(_am)())\n            {\n                balances[msg.sender]-=_am;\n                Log.AddMessage(msg.sender,_am,"Collect");\n            }\n'], [1, 'if(msg.sender.call.value(_am)())\n            {\n                balances[msg.sender]-=_am;\n                TransferLog.AddMessage(msg.sender,_am,"CashOut");\n            }\n'], [1, 'if(msg.sender.call.value(_am)())\n            {\n                balances[msg.sender]-=_am;\n                Log.AddMessage(msg.sender,_am,"Collect");\n            }\n'], [1, 'if(msg.sender.call.value(_am)())\n            {\n                acc.balance-=_am;\n                LogFile.AddMessage(msg.sender,_am,"Collect");\n            }\n'], [1, 'if(msg.sender.call.value(_am)())\n            {\n                balances[msg.sender]-=_am;\n                TransferLog.AddMessage(msg.sender,_am,"CashOut");\n            }\n'], [1, 'if(msg.sender.call.value(_am)())\n            {\n                balances[msg.sender]-=_am;\n                TransferLog.AddMessage(msg.sender,_am,"CashOut");\n            }\n'], [1, 'if(msg.sender.call.value(_am)())\n            {\n                acc.balance-=_am;\n                LogFile.AddMessage(msg.sender,_am,"Collect");\n            }\n'], [1, 'function Collect(uint _am)\n    public\n    payable\n    {\n        if(balances[msg.sender]>=MinSum && balances[msg.sender]>=_am)\n        {\n            // <yes> <report> REENTRANCY\n            if(msg.sender.call.value(_am)())\n            {\n                balances[msg.sender]-=_am;\n                Log.AddMessage(msg.sender,_am,"Collect");\n            }\n        }\n    }'], [1, 'function WithdrawToken(address token, uint256 amount,address to)\n    public \n    onlyOwner\n    {\n        token.call(bytes4(sha3("transfer(address,uint256)")),to,amount); \n    }'], [1, 'function CashOut(uint _am)\n    public\n    payable\n    {\n        if(_am<=balances[msg.sender]&&block.number>lastBlock)\n        {\n            // <yes> <report> REENTRANCY\n            if(msg.sender.call.value(_am)())\n            {\n                balances[msg.sender]-=_am;\n                TransferLog.AddMessage(msg.sender,_am,"CashOut");\n            }\n        }\n    }\n'], [1, 'function Collect(uint _am)\n    public\n    payable\n    {\n        if(balances[msg.sender]>=MinSum && balances[msg.sender]>=_am)\n        {\n            // <yes> <report> REENTRANCY\n            if(msg.sender.call.value(_am)())\n            {\n                balances[msg.sender]-=_am;\n                Log.AddMessage(msg.sender,_am,"Collect");\n            }\n        }\n    }\n'], [1, 'function Collect(uint _am)\n    public\n    payable\n    {\n        var acc = Acc[msg.sender];\n        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)\n        {\n            // <yes> <report> REENTRANCY\n            if(msg.sender.call.value(_am)())\n            {\n                acc.balance-=_am;\n                LogFile.AddMessage(msg.sender,_am,"Collect");\n            }\n        }\n    }\n'], [1, 'function Collect(uint _am)\n    public\n    payable\n    {\n        if(balances[msg.sender]>=MinSum && balances[msg.sender]>=_am)\n        {\n            // <yes> <report> REENTRANCY\n            if(msg.sender.call.value(_am)())\n            {\n                balances[msg.sender]-=_am;\n                Log.AddMessage(msg.sender,_am,"Collect");\n            }\n        }\n    }\n'], [1, 'function CashOut(uint _am)\n    public\n    payable\n    {\n        if(_am<=balances[msg.sender])\n        {\n            // <yes> <report> REENTRANCY\n            if(msg.sender.call.value(_am)())\n            {\n                balances[msg.sender]-=_am;\n                TransferLog.AddMessage(msg.sender,_am,"CashOut");\n            }\n        }\n    }\n'], [1, 'function CashOut(uint _am)\n    {\n        if(_am<=balances[msg.sender])\n        {            \n            // <yes> <report> REENTRANCY\n            if(msg.sender.call.value(_am)())\n            {\n                balances[msg.sender]-=_am;\n                TransferLog.AddMessage(msg.sender,_am,"CashOut");\n            }\n        }\n    }'], [1, 'function CashOut(uint _am)\n    public\n    payable\n    {\n        if(_am<=balances[msg.sender])\n        {\n            // <yes> <report> REENTRANCY\n            if(msg.sender.call.value(_am)())\n            {\n                balances[msg.sender]-=_am;\n                TransferLog.AddMessage(msg.sender,_am,"CashOut");\n            }\n        }\n    }\n'], [1, 'function Collect(uint _am)\n    public\n    payable\n    {\n        var acc = Acc[msg.sender];\n        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)\n        {\n            // <yes> <report> REENTRANCY\n            if(msg.sender.call.value(_am)())\n            {\n                acc.balance-=_am;\n                LogFile.AddMessage(msg.sender,_am,"Collect");\n            }\n        }\n    }\n'], [1, 'function Collect(uint _am)\n    public\n    payable\n    {\n        var acc = Acc[msg.sender];\n        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)\n        {\n            // <yes> <report> REENTRANCY\n            if(msg.sender.call.value(_am)())\n            {\n                acc.balance-=_am;\n                LogFile.AddMessage(msg.sender,_am,"Collect");\n            }\n        }\n    }\n'], [1, 'function Collect(uint _am)\n    public\n    payable\n    {\n        var acc = Acc[msg.sender];\n        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)\n        {\n            // <yes> <report> REENTRANCY\n            if(msg.sender.call.value(_am)())\n            {\n                acc.balance-=_am;\n                LogFile.AddMessage(msg.sender,_am,"Collect");\n            }\n        }\n    }\n'], [1, 'function withdrawBalance() {  \n  uint amountToWithdraw = userBalances[msg.sender];\n  if (!(msg.sender.call.value(amountToWithdraw)())) { throw; }\n  userBalances[msg.sender] = 0;\n }    \n'], [1, 'function withdrawFunds (uint256 _weiToWithdraw) public {\n        require(balances[msg.sender] >= _weiToWithdraw);\n        require(_weiToWithdraw <= withdrawalLimit);\n        require(now >= lastWithdrawTime[msg.sender] + 1 weeks);\n    require(msg.sender.call.value(_weiToWithdraw)());\n        balances[msg.sender] -= _weiToWithdraw;\n        lastWithdrawTime[msg.sender] = now;\n    }\n'], [1, 'function withdraw(uint _amount) public {\n    if(balances[msg.sender] >= _amount) {\n      // <yes> <report> REENTRANCY\n      if(msg.sender.call.value(_amount)()) {\n        _amount;\n      }\n      balances[msg.sender] -= _amount;\n    }\n  }\n'], [1, 'function withdrawBalance() public {\n        uint amountToWithdraw = userBalances[msg.sender];\n        (bool success, ) = msg.sender.call.value(amountToWithdraw)(""); \n        require(success);\n        userBalances[msg.sender] = 0;\n    }\n'], [1, '\n\n    function withdrawAll() public {\n        uint oCredit = credit[msg.sender];\n        if (oCredit > 0) {\n            balance -= oCredit;\n            bool callResult = msg.sender.call.value(oCredit)();\n            require (callResult);\n            credit[msg.sender] = 0;\n        }\n    }\n'], [1, '\n\n    function withdrawBalance() public {\n        uint amountToWithdraw = userBalances[msg.sender];\n        (bool success, ) = msg.sender.call.value(amountToWithdraw)(""); \n        require(success);\n        userBalances[msg.sender] = 0;\n    }\n'], [1, 'function withdrawBalance(){\n         if( ! (msg.sender.call.value(userBalance[msg.sender])() ) ){\n             throw;\n         }\n         userBalance[msg.sender] = 0;\n     }\n'], [1, 'function withdraw(uint amount) {\n    if (credit[msg.sender]>= amount) {\n      bool res = msg.sender.call.value(amount)();\n      credit[msg.sender]-=amount;\n    }\n  }'], [1, "function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external override {\n        address[] memory path = new address[](2);\n        uint amountToken;\n        uint amountETH;\n        { // scope for token{0,1}, avoids stack too deep errors\n        address token0 = IUniswapV2Pair(msg.sender).token0();\n        address token1 = IUniswapV2Pair(msg.sender).token1();\n        assert(msg.sender == UniswapV2Library.pairFor(factory, token0, token1)); // ensure that msg.sender is actually a V2 pair\n        assert(amount0 == 0 || amount1 == 0); // this strategy is unidirectional\n        path[0] = amount0 == 0 ? token0 : token1;\n        path[1] = amount0 == 0 ? token1 : token0;\n        amountToken = token0 == address(WETH) ? amount1 : amount0;\n        amountETH = token0 == address(WETH) ? amount0 : amount1;\n        }\n\n        assert(path[0] == address(WETH) || path[1] == address(WETH)); // this strategy only works with a V2 WETH pair\n        IERC20 token = IERC20(path[0] == address(WETH) ? path[1] : path[0]);\n        IUniswapV1Exchange exchangeV1 = IUniswapV1Exchange(factoryV1.getExchange(address(token))); // get V1 exchange\n\n        if (amountToken > 0) {\n            (uint minETH) = abi.decode(data, (uint)); // slippage parameter for V1, passed in by caller\n            token.approve(address(exchangeV1), amountToken);\n            uint amountReceived = exchangeV1.tokenToEthSwapInput(amountToken, minETH, uint(-1));\n            uint amountRequired = UniswapV2Library.getAmountsIn(factory, amountToken, path)[0];\n            assert(amountReceived > amountRequired); // fail if we didn't get enough ETH back to repay our flash loan\n            WETH.deposit{value: amountRequired}();\n            assert(WETH.transfer(msg.sender, amountRequired)); // return WETH to V2 pair\n            (bool success,) = sender.call{value: amountReceived - amountRequired}(new bytes(0)); // keep the rest! (ETH)\n            assert(success);\n        } else {\n            (uint minTokens) = abi.decode(data, (uint)); // slippage parameter for V1, passed in by caller\n            WETH.withdraw(amountETH);\n            uint amountReceived = exchangeV1.ethToTokenSwapInput{value: amountETH}(minTokens, uint(-1));\n            uint amountRequired = UniswapV2Library.getAmountsIn(factory, amountETH, path)[0];\n            assert(amountReceived > amountRequired); // fail if we didn't get enough tokens back to repay our flash loan\n            assert(token.transfer(msg.sender, amountRequired)); // return tokens to V2 pair\n            assert(token.transfer(sender, amountReceived - amountRequired)); // keep the rest! (tokens)\n        }\n    }\n"], [1, 'function invokeWallet(\n        address _wallet,\n        address _to,\n        uint256 _value,\n        bytes memory _data\n    )\n        internal\n        returns (bytes memory _res)\n    {\n        bool success;\n        (success, _res) = _wallet.call(abi.encodeWithSignature("invoke(address,uint256,bytes)", _to, _value, _data));\n        if (success) {\n            (_res) = abi.decode(_res, (bytes));\n        } else {\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n        }\n    }\n'], [1, '\n    function isERC721(address _nftContract, uint256 _tokenId) internal returns (bool) {\n        // solium-disable-next-line security/no-low-level-calls\n        (bool success, bytes memory result) = _nftContract.call(abi.encodeWithSignature("supportsInterface(bytes4)", 0x80ac58cd));\n        if (success && result[0] != 0x0)\n            return true;\n\n        // solium-disable-next-line security/no-low-level-calls\n        (success, result) = _nftContract.call(abi.encodeWithSignature("supportsInterface(bytes4)", 0x6466353c));\n        if (success && result[0] != 0x0)\n            return true;\n\n        // solium-disable-next-line security/no-low-level-calls\n        (success,) = _nftContract.call(abi.encodeWithSignature("ownerOf(uint256)", _tokenId));\n        return success;\n    }\n'], [1, 'function execute(address _to, uint _value, bytes memory _data, bytes memory _signatures) public {\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n        uint256 count = _signatures.length / 65;\n        require(count >= threshold, "MSW: Not enough signatures");\n        bytes32 txHash = keccak256(abi.encodePacked(byte(0x19), byte(0), address(this), _to, _value, _data, nonce));\n        nonce += 1;\n        uint256 valid = 0;\n        address lastSigner = address(0);\n        for (uint256 i = 0; i < count; i++) {\n            (v,r,s) = splitSignature(_signatures, i);\n            address recovered = ecrecover(keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32",txHash)), v, r, s);\n            require(recovered > lastSigner, "MSW: Badly ordered signatures"); // make sure signers are different\n            lastSigner = recovered;\n            if (isOwner[recovered]) {\n                valid += 1;\n                if (valid >= threshold) {\n                    // solium-disable-next-line security/no-call-value\n                    (bool success,) = _to.call.value(_value)(_data);\n                    require(success, "MSW: External call failed");\n                    emit Executed(_to, _value, _data);\n                    return;\n                }\n            }\n        }\n        // If not enough signatures for threshold, then the transaction is not executed\n        revert("MSW: Not enough valid signatures");\n    }\n'], [1, 'function invoke(address _target, uint _value, bytes calldata _data) external moduleOnly {\n        // solium-disable-next-line security/no-call-value\n        (bool success, ) = _target.call.value(_value)(_data);\n        require(success, "BW: call to target failed");\n        emit Invoked(msg.sender, _target, _value, _data);\n    }\n'], [1, 'function withdraw() public {\n    for (uint i = 0; i < activityCount; i++ ) {\n      address addr = activityAccounts[i].addr;\n      if (addr == msg.sender || msg.sender == owner) {\n        uint amount = activityAccounts[i].balance;\n        if (amount > 0) {\n          activityAccounts[i].balance = 0;\n          totalFundsWithdrawn += amount;\n          if (!addr.call.gas(withdrawGas).value(amount)()) {\n            //put back funds in case of err\n            activityAccounts[i].balance = amount;\n            totalFundsWithdrawn -= amount;\n            MessageEvent("err: error sending funds");\n            return;\n          }\n        }\n      }\n    }\n  }\n'], [2, 'function PopBonusCode() public {\n         require(0 <= bonusCodes.length); // this condition is always true since array lengths are unsigned\n         bonusCodes.length--; // an underflow can be caused here\n     }\n'], [2, '\n\n    function withdraw() {\n        withdrawalCounter += 1;\n       \n        require(fibonacciLibrary.delegatecall(fibSig, withdrawalCounter));\n        msg.sender.transfer(calculatedFibNumber * 1 ether);\n    }\n\n  \n    function() public {\n      \n        require(fibonacciLibrary.delegatecall(msg.data));\n    }\n\n'], [2, '\n    function IamMissing()\n        public\n    {\n        owner = msg.sender;\n    }\n'], [2, '\n    function missing()\n        public\n    {\n        owner = msg.sender;\n    }\n'], [2, 'function Constructor()\n        public\n    {\n        owner = msg.sender;\n    }\n'], [2, 'function set(uint256 key, uint256 value) public {\n         if (map.length <= key) {\n             map.length = key + 1;\n         }\n       \n         map[key] = value;\n     }\n'], [2, 'function newOwner(address _owner) external returns (bool) {\n    require(_owner != 0);\n    owners[_owner] = msg.sender;\n    return true;\n  }\n'], [2, 'function sendTo(address receiver, uint amount) public {\n       \n        require(tx.origin == owner);\n        receiver.transfer(amount);\n    }\n'], [2, '\n  function initWallet(address[] _owners, uint _required, uint _daylimit) {\n    initDaylimit(_daylimit);\n    initMultiowned(_owners, _required);\n  }\n'], [2, 'function kill(address _to) onlymanyowners(sha3(msg.data)) external {\n    suicide(_to);\n  }\n'], [2, '\n\n    function withdrawAll(address _recipient) public {\n     \n        require(tx.origin == owner);\n        _recipient.transfer(this.balance);\n    }\n'], [2, 'function forward(address callee, bytes _data) public {\n    \n    require(callee.delegatecall(_data)); \n  }\n'], [2, '\n         function DynamicPyramid() {\n                 creator = msg.sender; \n         }\n'], [2, '\n  function sudicideAnyone() {\n    selfdestruct(msg.sender);\n  }\n'], [2, '\n     function changeOwner(address _newOwner)\n         public\n     {\n        owner = _newOwner;\n     }\n'], [2, 'function refund() public {\n       \n         msg.sender.transfer(balances[msg.sender]);\n     }\n'], [2, '\n     function initWallet() public {\n         creator = msg.sender;\n     }\n'], [2, '\n\n     function withdraw(uint256 amount) public {\n        \n         require(amount >= balances[msg.sender]);\n         msg.sender.transfer(amount);\n         balances[msg.sender] -= amount;\n     }\n'], [3, 'function transfer(address _to, uint256 _value) public{\n        /* Check if sender has balance */\n        require(balanceOf[msg.sender] >= _value);\n        balanceOf[msg.sender] -= _value;\n        \n        balanceOf[_to] += _value;\n}\n'], [3, '\n\n     function add(uint value) returns (bool){\n        \n         sellerBalance += value; // possible overflow\n\n         // possible auditor assert\n         // assert(sellerBalance >= value);\n     }\n'], [3, 'function run(uint256 input) public {\n       \n        count += input;\n    }\n'], [3, 'function run(uint256 input) public {\n       \n        uint res = count - input;\n    }\n'], [3, '\n\n    function init(uint256 k, uint256 v) public {\n        \n        map[k] -= v;\n    }\n'], [3, 'function run(uint256 input) public {\n        \n        count -= input;\n    }\n'], [3, 'function run(uint256 input) public {\n       \n        count *= input;\n    }\n'], [3, '\n\n    function run(uint256 input) {\n        if (initialized == 0) {\n            return;\n        }\n       \n        count -= input;\n    }\n'], [3, 'function run(uint256 input) public {\n        if (initialized == 0) {\n            initialized = 1;\n            return;\n        }\n       \n        count -= input;\n    }\n'], [3, '\n\n    function add(uint256 deposit) public {\n      \n        balance += deposit;\n    }\n'], [3, '\n    function overflowaddtostate(uint256 input) public {\n             count += input;\n    }\n'], [3, '\n    function overflowmultostate(uint256 input) public {\n      \n        count *= input;\n    }\n'], [3, 'function underflowtostate(uint256 input) public {\n     \n        count -= input;\n    }\n'], [3, 'function overflowlocalonly(uint256 input) public {\n       \n        uint res = count + input;\n    }\n'], [3, '\n    function overflowmulocalonly(uint256 input) public {\n      \n        uint res = count * input;\n    }\n'], [3, '\n    function underflowlocalonly(uint256 input) public {\n      \n        uint res = count - input;\n    }\n']]
[[1, 'if(msg.sender.call.value(_am)())\n            {\n                acc.balance-=_am;\n                LogFile.AddMessage(msg.sender,_am,"Collect");\n            }\n'], [1, 'function invokeWallet(\n        address _wallet,\n        address _to,\n        uint256 _value,\n        bytes memory _data\n    )\n        internal\n        returns (bytes memory _res)\n    {\n        bool success;\n        (success, _res) = _wallet.call(abi.encodeWithSignature("invoke(address,uint256,bytes)", _to, _value, _data));\n        if (success) {\n            (_res) = abi.decode(_res, (bytes));\n        } else {\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n        }\n    }\n'], [3, '\n    function overflowaddtostate(uint256 input) public {\n             count += input;\n    }\n'], [2, '\n  function initWallet(address[] _owners, uint _required, uint _daylimit) {\n    initDaylimit(_daylimit);\n    initMultiowned(_owners, _required);\n  }\n']]
